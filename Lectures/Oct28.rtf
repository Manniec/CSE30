{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf500
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww26200\viewh13940\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Lab\
\'97 prepend -> insert to beginning = first have to move all items to the right to make room and then append to the beginning\
\'97 write answers to questions 5, 6, 7, 8 in README file\
\'97 everything you need to know is in scratchpad.cpp\
\'97 In coding use vector & list in labs (vector = array, list = linked list)\
\'97 note: vectors have a push_back(); method but not a push_front method (have to do that manually)\
\'97 list -> push_front for linked lists exists\
\
Max value in list algorithm:\
int findMax( std::vector<int> nums) \{\
	int max = nums[0]; //set default max to first item of array\
\
	for (int i = 1; i < nums.size(); i++)\{ //iterate through each item of array\
		if (nums[i] > max) \{\
			max = nums[i];\
		\}\
	\}\
	return max;\
\}\
\'97 Order of complexity: O(n)\
\'97 Complexity Analysis:\
	\'97 is the order of complexity always the same or does the algorithm have a best case and a worse case?\
		Theres nothing you can do to stop early in this case. Even if the first number in the array is the max, you still have\
		to check it against everything else in the array, So this algorithm has no best case/ worse case behaviour.\
		 -> O(n) complexity. (If you are given 10 items, you need to check 10 values so its always O(n))\
	\'97 note: its only a best case if for any size input it can terminate early (always assume n is large). So if \
	     you have a list of length 1, the order of complexity is still O(n) bc n = 1. Always assume n is as large \
	     as possible. Never try to talk about best and worse case.\
	\'97 if you have a best case include a description of the input to make it end fast.\
\
\
\
Searching and Sorting Algorithms\
\'97 \
bool findValue(std::vector<int> nums, int val)\{\
	for (int i = 0, i < nums.size(); i++)\{ 	// iterate through each item in the \
		if (nums [i] = val)\{\
			return true;			// if the thing is there then return true, else DO NOTHING\
		\}\
	\}\
	return false;					// if it reached this point without returning true, returns false\
\}\
\
\'97 Complexity Analysis: \
	- Best case O(1): if the first element (or anything in the beginning) of the list is what your searching for\
	- Worst case O(n) : when we search for something not in the list\
	\'97 Note: probability -> best case barely ever happens (for almost every single algorithm).\
	     on average the worst case is what occurs.\
	\'97 can\'92t make any assumptions about the input -> no way to make it faster\
\
\'97 Linear Search\
\
}